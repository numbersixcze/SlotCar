#include "driverlib.h"
#include <msp430.h>
#define TIMER_PERIOD   1000
#define DUTY_CYCLE     250
#define SPICLK         10000
#define BAUD_RATE      9600

uint8_t transmitData = 0x12, receivedData = 0x00;
uint8_t returnValue = 0x00;
uint16_t dutyCycle = DUTY_CYCLE;
uint8_t tmp=0;
uint8_t check = 0;
volatile unsigned int j = 0;
volatile unsigned int i;        // volatile to prevent optimization


uint8_t dataTxBuffer[5] ={0,};
uint8_t dataRxBuffer[50] ={0,};



void main (void)
{
    dataTxBuffer[0] = 0x20;
    dataTxBuffer[1] = 0x0C;
    dataTxBuffer[2] = 0xEA;
    dataTxBuffer[3] = 0x00;
    dataTxBuffer[4] = 0x00;

    WDT_A_hold(WDT_A_BASE);     //Stop WDT

    //P8.1 as PWM output
    GPIO_setAsPeripheralModuleFunctionOutputPin( GPIO_PORT_P8, GPIO_PIN1 );

    //Generate PWM
    Timer_A_outputPWMParam paramPWM = {0};
    paramPWM.clockSource = TIMER_A_CLOCKSOURCE_SMCLK;
    paramPWM.clockSourceDivider = TIMER_A_CLOCKSOURCE_DIVIDER_1;
    paramPWM.timerPeriod = TIMER_PERIOD;
    paramPWM.compareRegister = TIMER_A_CAPTURECOMPARE_REGISTER_1;
    paramPWM.compareOutputMode = TIMER_A_OUTPUTMODE_SET_RESET;
    paramPWM.dutyCycle = dutyCycle;
    Timer_A_outputPWM(TIMER_A0_BASE, &paramPWM);

    GPIO_setAsOutputPin( GPIO_PORT_P8, GPIO_PIN5);      //Disable H-bridge
    GPIO_setAsOutputPin( GPIO_PORT_P8, GPIO_PIN2);      //EN H-bridge
    GPIO_setOutputHighOnPin(GPIO_PORT_P8, GPIO_PIN2);
    GPIO_setOutputLowOnPin(GPIO_PORT_P8, GPIO_PIN5);

    //P5.6,7 = USCI_A1 TXD/RXD
    GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P5, GPIO_PIN6 + GPIO_PIN7);

    GPIO_setAsOutputPin(GPIO_PORT_P3,GPIO_PIN0);  //Set CS SPI
    GPIO_setOutputHighOnPin(GPIO_PORT_P3,GPIO_PIN0);  //Set CS SPI

    // LED Init
    GPIO_setAsOutputPin( GPIO_PORT_P1, GPIO_PIN2 + GPIO_PIN3);
    GPIO_setAsOutputPin( GPIO_PORT_P4, GPIO_PIN2);
    GPIO_setAsOutputPin( GPIO_PORT_P3, GPIO_PIN6);

    GPIO_setOutputLowOnPin( GPIO_PORT_P1, GPIO_PIN2 + GPIO_PIN3);
    GPIO_setOutputLowOnPin( GPIO_PORT_P4, GPIO_PIN2);
    GPIO_setOutputLowOnPin( GPIO_PORT_P3, GPIO_PIN6);

    //Set SPI pin's mode
    GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P3, GPIO_PIN1 + GPIO_PIN2 + GPIO_PIN3);

    //Initialize Master
    USCI_B_SPI_initMasterParam paramSPI = {0};
    paramSPI.selectClockSource = USCI_B_SPI_CLOCKSOURCE_SMCLK;
    paramSPI.clockSourceFrequency = UCS_getSMCLK();
    paramSPI.desiredSpiClock = SPICLK;
    paramSPI.msbFirst = USCI_B_SPI_MSB_FIRST;
    paramSPI.clockPhase = USCI_B_SPI_PHASE_DATA_CHANGED_ONFIRST_CAPTURED_ON_NEXT;
    paramSPI.clockPolarity = USCI_B_SPI_CLOCKPOLARITY_INACTIVITY_HIGH;
    returnValue =  USCI_B_SPI_initMaster(USCI_B0_BASE, &paramSPI);

    if (STATUS_FAIL == returnValue)
        return;
    USCI_B_SPI_enable(USCI_B0_BASE);  //Enable SPI module

    //Baudrate = 9600, clock freq = 1.048MHz
    //UCBRx = 109, UCBRFx = 0, UCBRSx = 2, UCOS16 = 0
    USCI_A_UART_initParam param = {0};
    param.selectClockSource = USCI_A_UART_CLOCKSOURCE_SMCLK;
    param.clockPrescalar = 109;
    param.firstModReg = 0;
    param.secondModReg = 2;
    param.parity = USCI_A_UART_NO_PARITY;
    param.msborLsbFirst = USCI_A_UART_LSB_FIRST;
    param.numberofStopBits = USCI_A_UART_ONE_STOP_BIT;
    param.uartMode = USCI_A_UART_MODE;
    param.overSampling = USCI_A_UART_LOW_FREQUENCY_BAUDRATE_GENERATION;
    if (STATUS_FAIL == USCI_A_UART_init(USCI_A1_BASE, &param))
    {return;}

    //Enable UART module for operation
    USCI_A_UART_enable(USCI_A1_BASE);
    for(i=100; i>0; i--);     // delay
    USCI_A_UART_transmitData(USCI_A1_BASE, transmitData);


    __enable_interrupt();

    //Enable Receive Interrupt
    USCI_A_UART_clearInterrupt(USCI_A1_BASE, USCI_A_UART_RECEIVE_INTERRUPT);
    USCI_A_UART_enableInterrupt(USCI_A1_BASE, USCI_A_UART_RECEIVE_INTERRUPT);


    //Enable Receive interrupt
    USCI_B_SPI_clearInterrupt(USCI_B0_BASE, USCI_B_SPI_RECEIVE_INTERRUPT);  //Tx

    USCI_B_SPI_clearInterrupt(USCI_B0_BASE, USCI_B_SPI_TRANSMIT_INTERRUPT);  // Rx

    //USCI_B_SPI_enableInterrupt(USCI_B0_BASE, USCI_B_SPI_TRANSMIT_INTERRUPT);




    //while (!USCI_B_SPI_getInterruptStatus(USCI_B0_BASE, USCI_B_SPI_TRANSMIT_INTERRUPT)) ;

    /*GPIO_setOutputLowOnPin(GPIO_PORT_P3,GPIO_PIN0);
    for(i=1000; i>0; i--);
    USCI_B_SPI_transmitData(USCI_B0_BASE, dataTxBuffer[0]); //Transmit Data to slave
    for(i=100; i>0; i--);     // delay
    USCI_B_SPI_transmitData(USCI_B0_BASE, dataTxBuffer[1]);
    GPIO_setOutputHighOnPin(GPIO_PORT_P3,GPIO_PIN0);*/

    /*for(i=10000; i>0; i--);     // delay
    GPIO_setOutputLowOnPin(GPIO_PORT_P3,GPIO_PIN0);
    for(i=10000; i>0; i--);     // delay
     */

    //USCI_B_SPI_enableInterrupt(USCI_B0_BASE, USCI_B_SPI_TRANSMIT_INTERRUPT); //Tx
    //USCI_B_SPI_enableInterrupt(USCI_B0_BASE, USCI_B_SPI_RECEIVE_INTERRUPT); //Rx


    while(1)
    {
        //P1OUT ^= 0x04;              // toggle P1.0
        for(i=10000; i>0; i--);     // delay

        transmitData = transmitData+1;        // Increment TX data
        transmitData %= 9;
        // Load data onto buffer
        USCI_A_UART_transmitData(USCI_A1_BASE, transmitData);
        while(check != 1);
        check = 0;

        ++dutyCycle;
        dutyCycle %= TIMER_PERIOD;
        paramPWM.dutyCycle = dutyCycle;
        Timer_A_outputPWM(TIMER_A0_BASE, &paramPWM);
        USCI_B_SPI_enableInterrupt(USCI_B0_BASE, USCI_B_SPI_TRANSMIT_INTERRUPT); //Tx
    }


    //For debugger
    //__no_operation();
}

        //******************************************************************************
        //
        //This is the USCI_B0 interrupt vector service routine.
        //
        //******************************************************************************
        /*#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
        #pragma vector=USCI_B0_VECTOR
        __interrupt
        #elif defined(__GNUC__)
        __attribute__((interrupt(USCI_B0_VECTOR)))
        #endif
        void USCI_B0_ISR (void)
        {

                       // toggle P1.0
            switch (__even_in_range(UCB0IV,4)) //switch(UCB0IV)
            {
            //Vector 2 - TXIFG - UCRXIFG
            case 2:
                USCI_B_SPI_disableInterrupt(USCI_B0_BASE, USCI_B_SPI_RECEIVE_INTERRUPT);
                P1OUT ^= 0x04;
                dataRxBuffer[j] = USCI_B_SPI_receiveData(USCI_B0_BASE);
                j++;
                j %=2;
                USCI_B_SPI_enableInterrupt(USCI_B0_BASE, USCI_B_SPI_RECEIVE_INTERRUPT); //Rx

                break;
            case 4: //UCTXIFG
                USCI_B_SPI_disableInterrupt(USCI_B0_BASE, USCI_B_SPI_TRANSMIT_INTERRUPT);
                P1OUT ^= 0x08;
                //while (USCI_B_SPI_isBusy(USCI_B0_BASE) == USCI_B_SPI_BUSY );

                switch (tmp)
                {
                default: tmp = 2;
                case 2:
                    for(i=10; i>0; i--);
                    USCI_B_SPI_transmitData(USCI_B0_BASE,dataTxBuffer[tmp]);
                    tmp = 3;
                    break;
                case 3:
                    for(i=10; i>0; i--);
                    USCI_B_SPI_transmitData(USCI_B0_BASE,dataTxBuffer[tmp]);
                    tmp = 4;
                    break;

                case 4:
                    for(i=10; i>0; i--);
                    USCI_B_SPI_transmitData(USCI_B0_BASE,dataTxBuffer[tmp]);
                    tmp = 2;
                    break;
                }


                //Send next value   // TOTO má být zakomentované
                if (tmp==0)
                {
                for(i=10; i>0; i--);
                USCI_B_SPI_transmitData(USCI_B0_BASE,dataTxBuffer[2]);
                tmp=1;
                }
                else
                {
                USCI_B_SPI_transmitData(USCI_B0_BASE,0x00);
                tmp=0;

                }                   // TOTO má být zakomentované
                //Delay between transmissions for slave to process information
                //USCI_B_SPI_enableInterrupt(USCI_B0_BASE, USCI_B_SPI_TRANSMIT_INTERRUPT); //Tx
                __delay_cycles(10);
                //for(i=200; i>0; i--);
                break;
                default: break;

            }


        }*/

        #if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
        #pragma vector=USCI_A1_VECTOR
        __interrupt
        #elif defined(__GNUC__)
        __attribute__((interrupt(USCI_A1_VECTOR)))
        #endif
        void USCI_A1_ISR (void)
        {
            switch (__even_in_range(UCA1IV,4))
            {
                //Vector 2 - RXIFG
                case 2:
                    receivedData = USCI_A_UART_receiveData(USCI_A1_BASE);
                    if(!(receivedData == transmitData))                   // Check value
                    {
                      while(1);
                    }
                    check =1;
                    break;
                default: break;
            }
        }

/*
        ??uint8_t sendData(uint16_t adress,uint8_t sData)
        {

        return()
        }
        ??uint16_t getData(uint16_t gData)
        {
        return(gData)
        }
*/
